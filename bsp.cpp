//////////////////////////////////////////////////////////////////////////////
// Model: fsa_eos.qm
// File:  ./bsp.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Product: Board Support Package for Arduino UNO
// Last Updated for Version: 4.1.06
// Date of the Last Update:  Jan 27, 2011
//
//                    Q u a n t u m     L e a P s
//                    ---------------------------
//                    innovating embedded systems
//
// Copyright (C) 2002-2011 Quantum Leaps, LLC. All rights reserved.
//
// This software may be distributed and modified under the terms of the GNU
// General Public License version 2 (GPL) as published by the Free Software
// Foundation and appearing in the file GPL.TXT included in the packaging of
// this file. Please note that GPL Section 2[b] requires that all works based
// on this software must also be made publicly available under the terms of
// the GPL ("Copyleft").
//
// Alternatively, this software may be distributed and modified under the
// terms of Quantum Leaps commercial licenses, which expressly supersede
// the GPL and are specifically designed for licensees interested in
// retaining the proprietary status of their code.
//
// Contact information:
// Quantum Leaps Web site:  http://www.quantum-leaps.com
// e-mail:                  info@quantum-leaps.com
//////////////////////////////////////////////////////////////////////////////
/**/
/* Focus Stacking assistant bsp */
/**/
/* debouncing algorithm inspired by Jack Ganssle's
http://www.eetimes.com/discussion/break-points/4024981/My-favorite-software-debouncers
*/

#include "qp_port.h"
#include "fsa.h"
#include "bsp.h"
//#include "Wprogram.h"

Q_DEFINE_THIS_FILE

//#define SAVE_POWER

/* Buttons on  pins 7,6,5 - port D */

#define BUTTON_MASK 0xe0  // 1110 0000
#define BUTTON_PIN  PIND  //input
#define BUTTON_PORT PORTD //output
#define BUTTON_DDR  DDRD  //direction
#define N_MASK 0x80    //near button
#define F_MASK 0x40    //far button
#define G_MASK 0x20    //go button

#define DEB_CHECKS 4      //debounce buffer depth

uint8_t DebouncedState = 0;            //last state of buttons
static uint8_t State[DEB_CHECKS] = {0};   //history of states
static uint8_t Index = 0;



/* LED on pin 8 */

#define LED_MASK 0x01
#define LED_DDR DDRB



#define TICK_DIVIDER       ((F_CPU / BSP_TICKS_PER_SEC / 1024) - 1)

#if TICK_DIVIDER > 255
#   error BSP_TICKS_PER_SEC too small
#elif TICK_DIVIDER < 2
#   error BSP_TICKS_PER_SEC too large
#endif




// ISRs ----------------------------------------------------------------------
ISR(TIMER2_COMPA_vect) {

    uint8_t j = 0xff;
    uint8_t tmpbyte;

    /* read buttons and do debouncing */
    State[ Index ] = BUTTON_PIN;
    ++Index;

    for( uint8_t i = 0; i < ( DEB_CHECKS - 1 ); i++ ) {
        j = j & State[ i ];
    }

    tmpbyte = ( j ^ DebouncedState );
    //Serial.println(tmpbyte, HEX );

    if( tmpbyte & N_MASK ) {    //near button changed
        //Serial.println("N Changed");
        if( j & N_MASK ) {    //N open
            AO_Controls->postFIFO(Q_NEW(QEvent, N_RELEASE_SIG));
            //QF::publish(Q_NEW(QEvent, N_RELEASE_SIG));
        }
        else {                //N closed
            AO_Controls->postFIFO(Q_NEW(QEvent, N_PRESS_SIG));
            //QF::publish(Q_NEW(QEvent, KEY_PRESSED_SIG));
        }
    }//if( tmpbyte & N_MASK ...

    if( tmpbyte & F_MASK ) {    //near button changed
        if( j & F_MASK ) {    //F open
            AO_Controls->postFIFO(Q_NEW(QEvent, F_RELEASE_SIG));
            //QF::publish(Q_NEW(QEvent, F_RELEASE_SIG));
        }
        else {                //F closed
            AO_Controls->postFIFO(Q_NEW(QEvent, F_PRESS_SIG));
            //QF::publish(Q_NEW(QEvent, KEY_PRESSED_SIG));
        }
    }//if( tmpbyte & F_MASK ...

    if( tmpbyte & G_MASK ) {    //near button changed
        if( j & G_MASK ) {    //G open
            AO_Controls->postFIFO(Q_NEW(QEvent, G_RELEASE_SIG));
            //QF::publish(Q_NEW(QEvent, G_RELEASE_SIG));
        }
        else {                //G closed
            AO_Controls->postFIFO(Q_NEW(QEvent, G_PRESS_SIG));
            //QF::publish(Q_NEW(QEvent, KEY_PRESSED_SIG));
        }
    }//if( tmpbyte & G_MASK ...

    DebouncedState = j;

    if( Index >= DEB_CHECKS ) { //ring maintenance
        Index = 0;
    }
    // No need to clear the interrupt source since the Timer2 compare
    // interrupt is automatically cleard in hardware when the ISR runs.

    QF::tick();                               // process all armed time events



}

//............................................................................
void BSP_init(void) {

    BUTTON_DDR = BUTTON_DDR & ~BUTTON_MASK;  //switch button pins to input
    BUTTON_PORT = BUTTON_PORT | BUTTON_MASK; //turn on pullups
    LED_DDR |= LED_MASK;


    Serial.begin(115200);   // set the highest stanard baud rate of 115200 bps
    Serial.println("Start");
    //Notify(PSTR("Start\r\n"));

    if (O_usb->Init() == -1) {                             //Initialize USB
        Notify(PSTR("OSCOKIRQ failed to assert.\r\n"));
        }


}
//............................................................................
void QF::onStartup(void) {
          // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking
    TCCR2A = (1 << WGM21) | (0 << WGM20);
    TCCR2B = (1 << CS22 ) | (1 << CS21) | (1 << CS20);               // 1/2^10
    ASSR &= ~(1 << AS2);
    TIMSK2 = (1 << OCIE2A);                 // Enable TIMER2 compare Interrupt
    TCNT2 = 0;
    OCR2A = TICK_DIVIDER;     // must be loaded last for Atmega168 and friends
}
//............................................................................
void QF::onCleanup(void) {
}
//............................................................................
#if (QP_VERSION < 0x4300 )
void QF::onIdle(QF_INT_KEY_TYPE key) {


#ifdef SAVE_POWER

    SMCR = (0 << SM0) | (1 << SE);  // idle sleep mode, adjust to your project

    // never separate the following two assembly instructions, see NOTE2
    __asm__ __volatile__ ("sei" "\n\t" :: );
    __asm__ __volatile__ ("sleep" "\n\t" :: );

    SMCR = 0;                                              // clear the SE bit

#else
    QF_INT_UNLOCK(key);
#endif
}

#else //#if (QP_VERSION < 0x4300

void QF::onIdle() {

#ifdef SAVE_POWER

    SMCR = (0 << SM0) | (1 << SE);  // idle sleep mode, adjust to your project

    // never separate the following two assembly instructions, see NOTE2
    __asm__ __volatile__ ("sei" "\n\t" :: );
    __asm__ __volatile__ ("sleep" "\n\t" :: );

    SMCR = 0;                                              // clear the SE bit

#else
    QF_INT_ENABLE();
#endif
}

#endif //#if (QP_VERSION < 0x4300


//............................................................................
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    cli();                                              // lock all interrupts
    LED_ON();
    Serial.print("ASSERT - line ");
    Serial.println(line);
    asm volatile ("jmp 0x0000");    // perform a software reset of the Arduino
}

// NOTE2:
// The QF_onIdle() callback is called with interrupts *locked* to prevent
// a race condtion of posting a new event from an interrupt while the
// system is already committed to go to sleep. The only *safe* way of
// going to sleep mode is to do it ATOMICALLY with enabling interrupts.
// As described in the "AVR Datasheet" in Section "Reset and Interrupt
// Handling", when using the SEI instruction to enable interrupts, the
// instruction following SEI will be executed before any pending interrupts.
// As the Datasheet shows in the assembly example, the pair of instructions
//     SEI       ; enable interrupts
//     SLEEP     ; go to the sleep mode
// executes ATOMICALLY, and so *no* interrupt can be serviced between these
// instructins. You should NEVER separate these two lines.
//

