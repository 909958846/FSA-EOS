//////////////////////////////////////////////////////////////////////////////
// Model: fsa_eos.qm
// File:  ./commands.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include <avrpins.h>
#include <max3421e.h>
#include <usbhost.h>
#include <usb_ch9.h>
#include <Usb.h>
#include <address.h>

#include <parsetools.h>

#include <ptp.h>
#include <canoneos.h>
#include <qp_port.h>
#include <valuelist.h>
#include <eosvaluetitles.h>
#include <eoseventparser.h>

#include "qp_port.h"
#include "bsp.h"
#include "fsa.h"

Q_DEFINE_THIS_FILE

/*
#define STEP_N1 0x01
#define STEP_N2 0x02
#define STEP_N3 0x03
#define STEP_F1 0x8001
#define STEP_F2 0x8002
#define STEP_F3 0x8003
*/

#define FM_CMD_DELAY BSP_TICKS_PER_SEC/2
#define CAP_CMD_DELAY BSP_TICKS_PER_SEC*3

class CamStateHandlers : public EOSStateHandlers
{
      enum CamStates { stInitial, stDisconnected, stConnected };
      CamStates stateConnected;

public:
      CamStateHandlers() : stateConnected(stInitial)
      {
      };

      virtual void OnDeviceDisconnectedState(PTP *ptp);
      virtual void OnDeviceInitializedState(PTP *ptp);
};

CamStateHandlers    CamStates;
USB                 Usb;
USB* const O_usb = &Usb;
CanonEOS            Eos(&Usb, &CamStates);

void CamStateHandlers::OnDeviceDisconnectedState(PTP *ptp)
{
    if (stateConnected == stConnected || stateConnected == stInitial)
    {
        stateConnected = stDisconnected;
        AO_Camera->postFIFO(Q_NEW(QEvent, CAM_DISC_SIG));
    }
}

void CamStateHandlers::OnDeviceInitializedState(PTP *ptp)
{
    uint16_t ptp_error;

    if (stateConnected == stDisconnected || stateConnected == stInitial) {
        stateConnected = stConnected;

    if((ptp_error = Eos.SetProperty(EOS_DPC_LiveView, 0)) != PTP_RC_OK) {    //turn off live view
        PTPTRACE2("AO Camera: LiveView off failed", ptp_error);
    }

    if((ptp_error = Eos.SetProperty(EOS_DPC_LiveView, 2)) != PTP_RC_OK) {    //turn on live view
        PTPTRACE2("AO Camera: LiveView mode 2 failed", ptp_error);
    }

        AO_Camera->postFIFO(Q_NEW(QEvent, CAM_READY_SIG));
    }//if(stateConnected...
}


//Commands class
// $(AOs::Commands) ..........................................................
/// Camera Commands
class Commands : public QActive {
private:
    /// PTP command delay
    QTimeEvt cmd_delay;
    /// focusing step property value
    uint16_t fstep_cmd;
    uint16_t focus_position;

public:
    /// camera control commands
    Commands() : QActive((QStateHandler)&Commands::initial), cmd_delay(CMD_DELAY_SIG), focus_position(0x7fff) {
    }

protected:
    static QState initial(Commands *me, QEvent const *e);
    static QState idle(Commands *me, QEvent const *e);
    static QState focus_move(Commands *me, QEvent const *e);
    static QState capture(Commands *me, QEvent const *e);
};

//Local objects
static Commands l_Commands;

//Global objects
QActive * const AO_Commands = &l_Commands;

//Commandss class definition
// $(AOs::Commands) ..........................................................

// $(AOs::Commands::Statechart) ..............................................
// @(/2/4/4/0)
QState Commands::initial(Commands *me, QEvent const *e) {
    return Q_TRAN(&Commands::idle);
}
// $(AOs::Commands::Statechart::idle) ........................................
QState Commands::idle(Commands *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/4/4/1)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Commands: Idle Entry\r\n"));
            return Q_HANDLED();
        }
        // @(/2/4/4/1)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Commands: Idle Exit\r\n"));
            return Q_HANDLED();
        }
        // @(/2/4/4/1/0)
        case NEAR_STEP_SIG: {
            me->fstep_cmd = NSTEP;
            return Q_TRAN(&Commands::focus_move);
        }
        // @(/2/4/4/1/1)
        case FAR_STEP_SIG: {
            me->fstep_cmd = FSTEP;

            return Q_TRAN(&Commands::focus_move);
        }
        // @(/2/4/4/1/2)
        case CAPTURE_SIG: {
            //Notify(PSTR("AO_Commands: Capture Signal\r\n"));
            return Q_TRAN(&Commands::capture);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Commands::Statechart::focus_move) ..................................
QState Commands::focus_move(Commands *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/4/4/2)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Commands: Focus Move Entry\r\n"));
            uint16_t ptp_error;
            if((ptp_error = Eos.MoveFocus(me->fstep_cmd)) != PTP_RC_OK) {    //one step towards the camera
                PTPTRACE2("AO_Commands: Focus Step failed", ptp_error);
                AO_Lights->postFIFO(Q_NEW(QEvent, LED_ERROR_SIG));
            }

            if(me->fstep_cmd == NSTEP) {
                --me->focus_position;
                }
                else {
                    ++me->focus_position;
                }
            me->cmd_delay.disarm();
            me->cmd_delay.postIn(me, FM_CMD_DELAY);
            return Q_HANDLED();
        }
        // @(/2/4/4/2)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Commands: Focus Move Exit\r\n"));

            return Q_HANDLED();
        }
        // @(/2/4/4/2/0)
        case CMD_DELAY_SIG: {
            //Notify(PSTR("AO_Commands: Focus Move: CMD_DELAY_SIG\r\n"));

            FocusMovedEvt *fme = Q_NEW( FocusMovedEvt, FOCUS_MOVED_SIG );
            fme->focus_position = me->focus_position;

            AO_Lights->postFIFO(Q_NEW(QEvent, LED_WORKING_SIG));

            AO_Camera->postFIFO( fme );
            return Q_TRAN(&Commands::idle);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Commands::Statechart::capture) .....................................
QState Commands::capture(Commands *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/4/4/3)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Commands: Capture Entry\r\n"));
            //AO_Lights->postLIFO(Q_NEW(QEvent, ALL_LEDS_OFF_SIG));
            //me->cap_delay.postIn(me, CAP_CMD_DELAY);

            //uint16_t ptp_error = Eos.MoveFocus(me->fstep_cmd); /* Eos.Capture(); */
            uint16_t ptp_error = Eos.Capture();
            me->cmd_delay.postIn(me, CAP_CMD_DELAY);
            //me->cap_delay.postIn(me, CAP_CMD_DELAY);
            //AO_Camera->postFIFO(Q_NEW(QEvent, CAP_COMPLETE_SIG));
            /*
            if (ptp_error != PTP_RC_OK) {
                PTPTRACE2("Capture Error", ptp_error);
            }
            */
            //me->postFIFO(Q_NEW(QEvent, CMD_DELAY_SIG));
            //me->cap_delay.disarm();



            return Q_HANDLED();
        }
        // @(/2/4/4/3)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Commands: Capture Exit\r\n"));
            AO_Camera->postFIFO(Q_NEW(QEvent, CAP_COMPLETE_SIG));
            return Q_HANDLED();
        }
        // @(/2/4/4/3/0)
        case CMD_DELAY_SIG: {
            //Notify(PSTR("AO_Commands: Capture Cmd Delay\r\n"));
            return Q_TRAN(&Commands::idle);
        }
    }
    return Q_SUPER(&QHsm::top);
}


