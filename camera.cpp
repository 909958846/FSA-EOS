//////////////////////////////////////////////////////////////////////////////
// Model: fsa_eos.qm
// File:  ./camera.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
/*
#include <avrpins.h>
#include <max3421e.h>
#include <usbhost.h>
#include <usb_ch9.h>
#include <Usb.h>
#include <address.h>

#include <parsetools.h>

#include <ptp.h>
#include <canoneos.h>
#include <qp_port.h>
#include <valuelist.h>
#include <eosvaluetitles.h>
#include <eoseventparser.h>
*/

#include "qp_port.h"
#include "bsp.h"
#include "fsa.h"

Q_DEFINE_THIS_FILE

/*
#define STEP_N1 0x01
#define STEP_N2 0x02
#define STEP_N3 0x03
#define STEP_F1 0x8001
#define STEP_F2 0x8002
#define STEP_F3 0x8003

#define COMMAND_DELAY BSP_TICKS_PER_SEC/10

class CamStateHandlers : public EOSStateHandlers
{
      enum CamStates { stInitial, stDisconnected, stConnected };
      CamStates stateConnected;

public:
      CamStateHandlers() : stateConnected(stInitial)
      {
      };

      virtual void OnDeviceDisconnectedState(PTP *ptp);
      virtual void OnDeviceInitializedState(PTP *ptp);
};

CamStateHandlers    CamStates;
USB                 Usb;
USB* const O_usb = &Usb;
CanonEOS            Eos(&Usb, &CamStates);

void CamStateHandlers::OnDeviceDisconnectedState(PTP *ptp)
{
    if (stateConnected == stConnected || stateConnected == stInitial)
    {
        stateConnected = stDisconnected;
        AO_Camera->postFIFO(Q_NEW(QEvent, CAM_DISC_SIG));
    }
}

void CamStateHandlers::OnDeviceInitializedState(PTP *ptp)
{

    if (stateConnected == stDisconnected || stateConnected == stInitial) {
        stateConnected = stConnected;
        AO_Camera->postFIFO(Q_NEW(QEvent, CAM_READY_SIG));
    }
}
*/

//Camera Class
// $(AOs::Camera) ............................................................
/// Camera control
class Camera : public QActive {
private:
    /// near focus point
    uint16_t n_point;
    /// far focus point
    uint16_t f_point;
    uint16_t focus_position;

public:
    Camera() : QActive((QStateHandler)&Camera::initial), n_point(0x7fff), f_point(0x7fff), focus_position(0x7fff) {
    }

protected:
    static QState initial(Camera *me, QEvent const *e);
    static QState operation(Camera *me, QEvent const *e);
    static QState disconnected(Camera *me, QEvent const *e);
    static QState control(Camera *me, QEvent const *e);
    static QState run(Camera *me, QEvent const *e);
    static QState shoot(Camera *me, QEvent const *e);
};

//Local objects
static Camera l_Camera;

//Global objects
QActive * const AO_Camera = &l_Camera;

//Camera Class definition
// $(AOs::Camera) ............................................................

// $(AOs::Camera::Statechart) ................................................
// @(/2/1/4/0)
QState Camera::initial(Camera *me, QEvent const *e) {
    return Q_TRAN(&Camera::operation);
}
// $(AOs::Camera::Statechart::operation) .....................................
QState Camera::operation(Camera *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/4/1/0)
        case CAM_DISC_SIG: {
            return Q_TRAN(&Camera::disconnected);
        }
        // @(/2/1/4/1/1)
        case CAM_READY_SIG: {
            AO_Lights->postFIFO(Q_NEW(QEvent, LED_IDLE_SIG));

            return Q_TRAN(&Camera::control);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Camera::Statechart::operation::disconnected) .......................
QState Camera::disconnected(Camera *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/4/1/2)
        case Q_ENTRY_SIG: {
            Notify(PSTR("Camera offline\r\n"));
            AO_Lights->postFIFO(Q_NEW(QEvent, LED_ERROR_SIG));

            return Q_HANDLED();
        }
    }
    return Q_SUPER(&Camera::operation);
}
// $(AOs::Camera::Statechart::operation::control) ............................
QState Camera::control(Camera *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/4/1/3)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO Camera: Control Entry\r\n"));

            return Q_HANDLED();
        }
        // @(/2/1/4/1/3)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO Camera: Control Exit\r\n"));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/0)
        case NEAR_SET_SIG: {
            //Serial.println("Near Set");
            me->n_point = me->focus_position;
            AO_Lights->postFIFO(Q_NEW(QEvent, LED_WORKING_SIG));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/1)
        case FAR_SET_SIG: {
            //Serial.println("Far Set");
            me->f_point = me->focus_position;
            AO_Lights->postFIFO(Q_NEW(QEvent, LED_WORKING_SIG));

            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/2)
        case RUN_SIG: {
            //Notify(PSTR("AO_Cam: Run Signal\r\n"));

            return Q_TRAN(&Camera::run);
        }
        // @(/2/1/4/1/3/3)
        case FREERUN_SIG: {
            //Notify(PSTR("AO_Cam: FreeRun Signal\r\n"));
            me->f_point = 0xffff;    //set far point as far as possible
            me->n_point = me->focus_position;
            return Q_TRAN(&Camera::run);
        }
        // @(/2/1/4/1/3/4)
        case NEAR_STEP_SIG: {
            AO_Commands->postFIFO(Q_NEW(QEvent, NEAR_STEP_SIG));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/5)
        case FAR_STEP_SIG: {
            AO_Commands->postFIFO(Q_NEW(QEvent, FAR_STEP_SIG));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/6)
        case FOCUS_MOVED_SIG: {
            me->focus_position = ((FocusMovedEvt *)e)->focus_position;
            return Q_HANDLED();
        }
    }
    return Q_SUPER(&Camera::operation);
}
// $(AOs::Camera::Statechart::operation::control::run) .......................
QState Camera::run(Camera *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/4/1/3/7)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Camera: Run Entry\r\n"));
            if( me->focus_position == me->n_point ) {    //lens at near point
                me->postFIFO(Q_NEW(QEvent, SHOOT_SIG));
                }
                else {
                    if( me->focus_position > me->n_point ) { //step back to N-point
                        AO_Commands->postFIFO(Q_NEW(QEvent, NEAR_STEP_SIG));
                    }
                    else {                                    //step forward to N-point
                        AO_Commands->postFIFO(Q_NEW(QEvent, FAR_STEP_SIG));
                    }
                }

            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/7)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Camera: Run Exit\r\n"));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/7/0)
        case SHOOT_SIG: {
            //Notify(PSTR("Time to Shoot\r\n"));
            return Q_TRAN(&Camera::shoot);
        }
        // @(/2/1/4/1/3/7/1)
        case FOCUS_MOVED_SIG: {
            me->focus_position = ((FocusMovedEvt *)e)->focus_position;
            return Q_TRAN(&Camera::run);
        }
        // @(/2/1/4/1/3/7/2)
        case NEAR_STEP_SIG: {
            return Q_TRAN(&Camera::control);
        }
        // @(/2/1/4/1/3/7/3)
        case FAR_STEP_SIG: {
            return Q_TRAN(&Camera::control);
        }
    }
    return Q_SUPER(&Camera::control);
}
// $(AOs::Camera::Statechart::operation::control::run::shoot) ................
QState Camera::shoot(Camera *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/1/4/1/3/7/4)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Camera: Shoot Entry\r\n"));
            if( me->focus_position <= me->f_point ) {
                AO_Commands->postFIFO(Q_NEW(QEvent, CAPTURE_SIG));
            }

            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/7/4/0)
        case CAP_COMPLETE_SIG: {
            AO_Commands->postFIFO(Q_NEW(QEvent, FAR_STEP_SIG));
            return Q_HANDLED();
        }
        // @(/2/1/4/1/3/7/4/1)
        case FOCUS_MOVED_SIG: {
            me->focus_position = ((FocusMovedEvt *)e)->focus_position;
            return Q_TRAN(&Camera::shoot);
        }
    }
    return Q_SUPER(&Camera::run);
}


