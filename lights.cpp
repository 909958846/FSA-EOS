//////////////////////////////////////////////////////////////////////////////
// Model: fsa_eos.qm
// File:  ./lights.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "bsp.h"
#include "fsa.h"

Q_DEFINE_THIS_FILE

#define LED_IDLE_PER_TIME BSP_TICKS_PER_SEC*2    //idle LED period time
#define LED_IDLE_ON_TIME BSP_TICKS_PER_SEC/50    //idle LED on time
#if LED_IDLE_ON_TIME < 2
#   error LED Idle On Time: BSP_TICKS_PER_SEC too small
#endif

#define LED_ERR_PER_TIME BSP_TICKS_PER_SEC/5    //error LED period time
#define LED_ERR_ON_TIME BSP_TICKS_PER_SEC/10   //error LED on time

#define LED_WORKING_FLASH_TIME BSP_TICKS_PER_SEC/20
#define LED_WORKING_FLASH_CNT 1

//Lights class
// $(AOs::Lights) ............................................................
/// LED control
class Lights : public QActive {
private:
    QTimeEvt led_per_timeout;
    QTimeEvt led_on_timeout;
    /// LED flash counter
    uint8_t led_flash_cnt;
    uint8_t period_time;
    uint8_t on_time;
    QTimeEvt led_work_timeout;

public:
    Lights() : QActive((QStateHandler)&Lights::initial), led_per_timeout(LED_PER_TIMEOUT_SIG), led_on_timeout(LED_ON_TIMEOUT_SIG), led_work_timeout(LED_WORK_TIMEOUT_SIG) {
    }

protected:
    static QState initial(Lights *me, QEvent const *e);
    static QState Blinker(Lights *me, QEvent const *e);
    static QState led_periodic(Lights *me, QEvent const *e);
    static QState led_working(Lights *me, QEvent const *e);
};

//Local objects
static Lights l_Lights;

//Global objects
QActive * const AO_Lights = &l_Lights;

//Lights class definition
// $(AOs::Lights) ............................................................

// $(AOs::Lights::Statechart) ................................................
// @(/2/2/7/0)
QState Lights::initial(Lights *me, QEvent const *e) {
    return Q_TRAN(&Lights::Blinker);
}
// $(AOs::Lights::Statechart::Blinker) .......................................
QState Lights::Blinker(Lights *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/2/7/1)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("Blinker entry\r\n"));

            return Q_HANDLED();
        }
        // @(/2/2/7/1)
        case Q_EXIT_SIG: {
            //Notify(PSTR("Blinker exit\r\n"));
            return Q_HANDLED();
        }
        // @(/2/2/7/1/0)
        case LED_IDLE_SIG: {
            me->period_time = LED_IDLE_PER_TIME;
            me->on_time = LED_IDLE_ON_TIME;
            return Q_TRAN(&Lights::led_periodic);
        }
        // @(/2/2/7/1/1)
        case LED_WORKING_SIG: {
            return Q_TRAN(&Lights::led_working);
        }
        // @(/2/2/7/1/2)
        case LED_ERROR_SIG: {
            me->period_time = LED_ERR_PER_TIME;
            me->on_time = LED_ERR_ON_TIME;
            return Q_TRAN(&Lights::led_periodic);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Lights::Statechart::Blinker::led_periodic) .........................
QState Lights::led_periodic(Lights *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/2/7/1/3)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Lights: LED Periodic Entry\r\n"));
            LED_ON();
            me->led_per_timeout.disarm();
            me->led_on_timeout.disarm();
            me->led_per_timeout.postIn(me, me->period_time);
            me->led_on_timeout.postIn(me, me->on_time);
            return Q_HANDLED();
        }
        // @(/2/2/7/1/3)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Lights: LED Periodic Exit\r\n"));
            return Q_HANDLED();
        }
        // @(/2/2/7/1/3/0)
        case LED_PER_TIMEOUT_SIG: {
            LED_ON();
            me->led_on_timeout.postIn(me, me->on_time);
            me->led_per_timeout.postIn(me, me->period_time);
            return Q_HANDLED();
        }
        // @(/2/2/7/1/3/1)
        case LED_ON_TIMEOUT_SIG: {
            LED_OFF();
            return Q_HANDLED();
        }
    }
    return Q_SUPER(&Lights::Blinker);
}
// $(AOs::Lights::Statechart::led_working) ...................................
QState Lights::led_working(Lights *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/2/7/2)
        case Q_ENTRY_SIG: {
            //Notify(PSTR("AO_Lights: LED Working Entry\r\n"));
            me->led_work_timeout.postEvery(me, LED_WORKING_FLASH_TIME);
            me->led_flash_cnt = LED_WORKING_FLASH_CNT*2 + 1;

            return Q_HANDLED();
        }
        // @(/2/2/7/2)
        case Q_EXIT_SIG: {
            //Notify(PSTR("AO_Lights: LED Working Exit\r\n"));
            me->led_work_timeout.disarm();
            return Q_HANDLED();
        }
        // @(/2/2/7/2/0)
        case LED_WORK_TIMEOUT_SIG: {
            // @(/2/2/7/2/0/0)
            if (me->led_flash_cnt != 0) {
                --me->led_flash_cnt;
                // @(/2/2/7/2/0/0/0)
                if ((me->led_flash_cnt & 1 ) == 0) {
                    LED_ON();
                    return Q_HANDLED();
                }
                // @(/2/2/7/2/0/0/1)
                else {
                    LED_OFF();
                    return Q_HANDLED();
                }
            }
            // @(/2/2/7/2/0/1)
            else {
                LED_OFF();
                //return Q_TRAN(me->led_history); //transition to history

                return Q_TRAN(&Lights::led_periodic);
            }
        }
    }
    return Q_SUPER(&QHsm::top);
}


