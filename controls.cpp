//////////////////////////////////////////////////////////////////////////////
// Model: fsa_eos.qm
// File:  ./controls.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "bsp.h"
#include "fsa.h"
#include "ptp.h"


Q_DEFINE_THIS_FILE

#define LP_TIMEOUT BSP_TICKS_PER_SEC    //long press time

//Controls class
// $(AOs::Controls) ..........................................................
/// Button interface. Transforms single presses, double presses, long presses to commands
class Controls : public QActive {
private:
    /// Long press time
    QTimeEvt lp_timeout;

public:
    Controls() : QActive((QStateHandler)&Controls::initial), lp_timeout(LP_TIMEOUT_SIG) {
    }

protected:
    static QState initial(Controls *me, QEvent const *e);
    static QState Buttons(Controls *me, QEvent const *e);
    static QState N_Handler(Controls *me, QEvent const *e);
    static QState F_Handler(Controls *me, QEvent const *e);
    static QState G_Handler(Controls *me, QEvent const *e);
};

//Local objects
static Controls l_Controls;

//Global objects
QActive * const AO_Controls = &l_Controls;

//Controls class definition
// $(AOs::Controls) ..........................................................

// $(AOs::Controls::Statechart) ..............................................
// @(/2/0/2/0)
QState Controls::initial(Controls *me, QEvent const *e) {
    //Serial.println("Intf.initial");

    return Q_TRAN(&Controls::Buttons);
}
// $(AOs::Controls::Statechart::Buttons) .....................................
QState Controls::Buttons(Controls *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/0/2/1)
        case Q_ENTRY_SIG: {
            //Serial.println("Intf.entry");

            return Q_HANDLED();
        }
        // @(/2/0/2/1)
        case Q_EXIT_SIG: {
            me->lp_timeout.disarm();
            me->lp_timeout.postIn(me, LP_TIMEOUT);
            return Q_HANDLED();
        }
        // @(/2/0/2/1/0)
        case N_PRESS_SIG: {
            //Serial.println("N Pressed");
            //me->lp_timeout.postIn(me, LP_TIMEOUT);

            return Q_TRAN(&Controls::N_Handler);
        }
        // @(/2/0/2/1/1)
        case F_PRESS_SIG: {
            //Serial.println("F Pressed");
            //me->lp_timeout.postIn(me, LP_TIMEOUT);
            return Q_TRAN(&Controls::F_Handler);
        }
        // @(/2/0/2/1/2)
        case G_PRESS_SIG: {
            //Serial.println("G Pressed");
            //me->lp_timeout.postIn(me, LP_TIMEOUT);
            return Q_TRAN(&Controls::G_Handler);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Controls::Statechart::N_Handler) ...................................
QState Controls::N_Handler(Controls *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/0/2/2/0)
        case N_RELEASE_SIG: {
            if( me->lp_timeout.disarm() == 1 ) {
                AO_Camera->postFIFO(Q_NEW(QEvent, NEAR_STEP_SIG));
            }
            return Q_TRAN(&Controls::Buttons);
        }
        // @(/2/0/2/2/1)
        case LP_TIMEOUT_SIG: {
            AO_Camera->postFIFO(Q_NEW(QEvent, NEAR_SET_SIG));
            //Serial.println("N Longpress");
            return Q_TRAN(&Controls::Buttons);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Controls::Statechart::F_Handler) ...................................
QState Controls::F_Handler(Controls *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/0/2/3/0)
        case F_RELEASE_SIG: {
            if( me->lp_timeout.disarm() == 1 ) {
                AO_Camera->postFIFO(Q_NEW(QEvent, FAR_STEP_SIG));
            }
            return Q_TRAN(&Controls::Buttons);
        }
        // @(/2/0/2/3/1)
        case LP_TIMEOUT_SIG: {
            AO_Camera->postFIFO(Q_NEW(QEvent, FAR_SET_SIG));
            //Serial.println("F Longpress");
            return Q_TRAN(&Controls::Buttons);
        }
    }
    return Q_SUPER(&QHsm::top);
}
// $(AOs::Controls::Statechart::G_Handler) ...................................
QState Controls::G_Handler(Controls *me, QEvent const *e) {
    switch (e->sig) {
        // @(/2/0/2/4/0)
        case G_RELEASE_SIG: {
            if( me->lp_timeout.disarm() == 1 ) {
                AO_Camera->postFIFO(Q_NEW(QEvent, RUN_SIG));
            }

            return Q_TRAN(&Controls::Buttons);
        }
        // @(/2/0/2/4/1)
        case LP_TIMEOUT_SIG: {
            AO_Camera->postFIFO(Q_NEW(QEvent, FREERUN_SIG));
            //AO_Lights->postFIFO(Q_NEW(QEvent, LED_WORKING_SIG));
            //Serial.println("G_Free run");

            return Q_TRAN(&Controls::Buttons);
        }
    }
    return Q_SUPER(&QHsm::top);
}








